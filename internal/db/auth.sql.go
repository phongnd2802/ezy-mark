// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: auth.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkRefreshTokenUsed = `-- name: CheckRefreshTokenUsed :one
SELECT COUNT(*)
FROM "user_session"
WHERE "refresh_token_used" = $1
`

func (q *Queries) CheckRefreshTokenUsed(ctx context.Context, refreshTokenUsed pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, checkRefreshTokenUsed, refreshTokenUsed)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const checkUserBaseExists = `-- name: CheckUserBaseExists :one
SELECT COUNT(*)
FROM "user_base"
WHERE "user_email" = $1
`

func (q *Queries) CheckUserBaseExists(ctx context.Context, userEmail string) (int64, error) {
	row := q.db.QueryRow(ctx, checkUserBaseExists, userEmail)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUserBase = `-- name: CreateUserBase :one
INSERT INTO "user_base" (
    "user_email",
    "user_password",
    "user_hash",
    "user_otp"
) VALUES ($1, $2, $3, $4) RETURNING user_id, user_email, user_hash, user_password, user_otp, is_verified, is_deleted, created_at, updated_at
`

type CreateUserBaseParams struct {
	UserEmail    string `json:"user_email"`
	UserPassword string `json:"user_password"`
	UserHash     string `json:"user_hash"`
	UserOtp      string `json:"user_otp"`
}

func (q *Queries) CreateUserBase(ctx context.Context, arg CreateUserBaseParams) (UserBase, error) {
	row := q.db.QueryRow(ctx, createUserBase,
		arg.UserEmail,
		arg.UserPassword,
		arg.UserHash,
		arg.UserOtp,
	)
	var i UserBase
	err := row.Scan(
		&i.UserID,
		&i.UserEmail,
		&i.UserHash,
		&i.UserPassword,
		&i.UserOtp,
		&i.IsVerified,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserProfile = `-- name: CreateUserProfile :one
INSERT INTO "user_profile" (
    "user_id",
    "user_email",
    "user_nickname"
) VALUES ($1, $2, $3) RETURNING user_id, user_email, user_nickname, user_fullname, user_avatar, user_mobile, user_gender, user_birthday, created_at, updated_at
`

type CreateUserProfileParams struct {
	UserID       int64  `json:"user_id"`
	UserEmail    string `json:"user_email"`
	UserNickname string `json:"user_nickname"`
}

func (q *Queries) CreateUserProfile(ctx context.Context, arg CreateUserProfileParams) (UserProfile, error) {
	row := q.db.QueryRow(ctx, createUserProfile, arg.UserID, arg.UserEmail, arg.UserNickname)
	var i UserProfile
	err := row.Scan(
		&i.UserID,
		&i.UserEmail,
		&i.UserNickname,
		&i.UserFullname,
		&i.UserAvatar,
		&i.UserMobile,
		&i.UserGender,
		&i.UserBirthday,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserSession = `-- name: CreateUserSession :one
INSERT INTO "user_session" (
    "sub_token",
    "refresh_token",
    "user_agent",
    "client_ip",
    "user_login_time",
    "expires_at",
    "user_id"
) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING session_id, sub_token, user_id, refresh_token, refresh_token_used, user_agent, client_ip, is_blocked, user_login_time, expires_at, created_at
`

type CreateUserSessionParams struct {
	SubToken      string             `json:"sub_token"`
	RefreshToken  string             `json:"refresh_token"`
	UserAgent     string             `json:"user_agent"`
	ClientIp      string             `json:"client_ip"`
	UserLoginTime pgtype.Timestamptz `json:"user_login_time"`
	ExpiresAt     time.Time          `json:"expires_at"`
	UserID        int64              `json:"user_id"`
}

func (q *Queries) CreateUserSession(ctx context.Context, arg CreateUserSessionParams) (UserSession, error) {
	row := q.db.QueryRow(ctx, createUserSession,
		arg.SubToken,
		arg.RefreshToken,
		arg.UserAgent,
		arg.ClientIp,
		arg.UserLoginTime,
		arg.ExpiresAt,
		arg.UserID,
	)
	var i UserSession
	err := row.Scan(
		&i.SessionID,
		&i.SubToken,
		&i.UserID,
		&i.RefreshToken,
		&i.RefreshTokenUsed,
		&i.UserAgent,
		&i.ClientIp,
		&i.IsBlocked,
		&i.UserLoginTime,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteSessionBySubToken = `-- name: DeleteSessionBySubToken :exec
DELETE FROM "user_session"
WHERE "sub_token" = $1
`

func (q *Queries) DeleteSessionBySubToken(ctx context.Context, subToken string) error {
	_, err := q.db.Exec(ctx, deleteSessionBySubToken, subToken)
	return err
}

const deleteSessionByUserId = `-- name: DeleteSessionByUserId :exec
DELETE FROM "user_session"
WHERE "user_id" = $1
`

func (q *Queries) DeleteSessionByUserId(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, deleteSessionByUserId, userID)
	return err
}

const getRoleByUserId = `-- name: GetRoleByUserId :many
SELECT "role_id"
FROM "user_roles"
WHERE "user_id" = $1
`

func (q *Queries) GetRoleByUserId(ctx context.Context, userID int64) ([]int32, error) {
	rows, err := q.db.Query(ctx, getRoleByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int32{}
	for rows.Next() {
		var role_id int32
		if err := rows.Scan(&role_id); err != nil {
			return nil, err
		}
		items = append(items, role_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionByRefreshTokenUsed = `-- name: GetSessionByRefreshTokenUsed :one
SELECT "session_id", "user_id", "refresh_token", "refresh_token_used"
FROM "user_session"
WHERE "refresh_token_used" = $1
`

type GetSessionByRefreshTokenUsedRow struct {
	SessionID        int64       `json:"session_id"`
	UserID           int64       `json:"user_id"`
	RefreshToken     string      `json:"refresh_token"`
	RefreshTokenUsed pgtype.Text `json:"refresh_token_used"`
}

func (q *Queries) GetSessionByRefreshTokenUsed(ctx context.Context, refreshTokenUsed pgtype.Text) (GetSessionByRefreshTokenUsedRow, error) {
	row := q.db.QueryRow(ctx, getSessionByRefreshTokenUsed, refreshTokenUsed)
	var i GetSessionByRefreshTokenUsedRow
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.RefreshToken,
		&i.RefreshTokenUsed,
	)
	return i, err
}

const getSessionBySubToken = `-- name: GetSessionBySubToken :one
SELECT "session_id", "user_id", "refresh_token", "refresh_token_used"
FROM "user_session"
WHERE "sub_token" = $1 
LIMIT 1
`

type GetSessionBySubTokenRow struct {
	SessionID        int64       `json:"session_id"`
	UserID           int64       `json:"user_id"`
	RefreshToken     string      `json:"refresh_token"`
	RefreshTokenUsed pgtype.Text `json:"refresh_token_used"`
}

func (q *Queries) GetSessionBySubToken(ctx context.Context, subToken string) (GetSessionBySubTokenRow, error) {
	row := q.db.QueryRow(ctx, getSessionBySubToken, subToken)
	var i GetSessionBySubTokenRow
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.RefreshToken,
		&i.RefreshTokenUsed,
	)
	return i, err
}

const getUserBaseByEmail = `-- name: GetUserBaseByEmail :one
SELECT user_id, user_email, user_hash, user_password, user_otp, is_verified, is_deleted, created_at, updated_at 
FROM "user_base"
WHERE "user_email" = $1
`

func (q *Queries) GetUserBaseByEmail(ctx context.Context, userEmail string) (UserBase, error) {
	row := q.db.QueryRow(ctx, getUserBaseByEmail, userEmail)
	var i UserBase
	err := row.Scan(
		&i.UserID,
		&i.UserEmail,
		&i.UserHash,
		&i.UserPassword,
		&i.UserOtp,
		&i.IsVerified,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserBaseById = `-- name: GetUserBaseById :one
SELECT user_id, user_email, user_hash, user_password, user_otp, is_verified, is_deleted, created_at, updated_at
FROM "user_base"
WHERE "user_id" = $1
`

func (q *Queries) GetUserBaseById(ctx context.Context, userID int64) (UserBase, error) {
	row := q.db.QueryRow(ctx, getUserBaseById, userID)
	var i UserBase
	err := row.Scan(
		&i.UserID,
		&i.UserEmail,
		&i.UserHash,
		&i.UserPassword,
		&i.UserOtp,
		&i.IsVerified,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByUserHash = `-- name: GetUserByUserHash :one
SELECT user_id, user_email, user_hash, user_password, user_otp, is_verified, is_deleted, created_at, updated_at
FROM "user_base"
WHERE "user_hash" = $1
`

func (q *Queries) GetUserByUserHash(ctx context.Context, userHash string) (UserBase, error) {
	row := q.db.QueryRow(ctx, getUserByUserHash, userHash)
	var i UserBase
	err := row.Scan(
		&i.UserID,
		&i.UserEmail,
		&i.UserHash,
		&i.UserPassword,
		&i.UserOtp,
		&i.IsVerified,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSession = `-- name: UpdateSession :exec
UPDATE "user_session"
SET "refresh_token" = $1, "refresh_token_used" = $2, "expires_at" = $3, "sub_token" = $4
WHERE "session_id" = $5
`

type UpdateSessionParams struct {
	RefreshToken     string      `json:"refresh_token"`
	RefreshTokenUsed pgtype.Text `json:"refresh_token_used"`
	ExpiresAt        time.Time   `json:"expires_at"`
	SubToken         string      `json:"sub_token"`
	SessionID        int64       `json:"session_id"`
}

func (q *Queries) UpdateSession(ctx context.Context, arg UpdateSessionParams) error {
	_, err := q.db.Exec(ctx, updateSession,
		arg.RefreshToken,
		arg.RefreshTokenUsed,
		arg.ExpiresAt,
		arg.SubToken,
		arg.SessionID,
	)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE "user_base"
SET "user_password" = $1, "updated_at" = now()
WHERE "user_id" = $2
`

type UpdateUserPasswordParams struct {
	UserPassword string `json:"user_password"`
	UserID       int64  `json:"user_id"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.UserPassword, arg.UserID)
	return err
}

const updateUserVerify = `-- name: UpdateUserVerify :one
UPDATE "user_base"
SET "is_verified" = true
WHERE "user_hash" = $1 RETURNING user_id, user_email, user_hash, user_password, user_otp, is_verified, is_deleted, created_at, updated_at
`

func (q *Queries) UpdateUserVerify(ctx context.Context, userHash string) (UserBase, error) {
	row := q.db.QueryRow(ctx, updateUserVerify, userHash)
	var i UserBase
	err := row.Scan(
		&i.UserID,
		&i.UserEmail,
		&i.UserHash,
		&i.UserPassword,
		&i.UserOtp,
		&i.IsVerified,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
